\ фиксированно-именованные локальные переменные на стеке параметров

\ положить адрес выбранного самого нижнего параметра на стеке в регистр ESI 
: sset \ offset --
 0xF58B W,            \ MOV     ESI , EBP
 0xC683 W, C,         \ ADD     ESI , # offset
; 
\  положить ESI на стек возвратов
M: rs   RS=S          \ PUSH    ESI
;
\  снять со стека возвратов и положить в ESI
M: sr   S=RS          \ POP     ESI
;
\ положить выбранный параметр на вершину стека
: N> \ n --
0x4589 W, 0xFC C,     \ MOV     FC [EBP] , EAX
0x6D8D W, 0xFC C,     \ LEA     EBP , FC [EBP]
0x468B W, C,          \ MOV     EAX ,  n [ESI] 
;
 
\ положить выбранный параметр в EDX
: d=@s 
  0x568B W, C,        \ MOV     EDX ,  n [ESI]
;
\ положить параметр из EDX в выбранную ячейку стека
: @s=d 
  0x5689 W, C,        \ MOV     n [ESI] ,  EDX   
;
\ снять параметр с вершины стека в выбранную ячейку стека
: @s=a  \ n --
  0x4689 W, C, 
  0x458B W, 0x00 C, 
  0x6D8D W, 0x4 C, 
;
: s@s=a \ n --
  0x4689 W, C, 
; 
\ положить выбранный параметр на вершину стека ( на вершину стека)
: a=@s  0x468B W, C,  \ MOV     EAX , n [ESI] 
;
I: o0x0 
 0x6D8D W, C,         \ LEA     EBP , n [EBP] 
 0x458B W, -4 C,      \ MOV     FC [EBP] , EAX
; 
I: o1x1 
 0x6D8D W, C,         \ LEA     EBP , n [EBP] 
; 
I: o2x2 
 0x5D8B W, 0x00 C,    \ MOV     EBX , 0 [EBP]
 0x6D8D W, C,         \ LEA     EBP , n [EBP]
 0x5D89 W, 0x00 C,    \ MOV     0 [EBP] , EBX
; 
I: o3x3 
 0x5D8B W, 0x00 C,    \ MOV     EBX , 0 [EBP]
 0x4D8B W, 0x04 C,    \ MOV     ECX , 4 [EBP]
 0x6D8D W, C,         \ LEA     EBP , n [EBP]
 0x5D89 W, 0x00 C,    \ MOV     0 [EBP] , EBX
 0x4D89 W, 0x04 C,    \ MOV     4 [EBP] , ECX
; 
I: o4x4 
 0x5D8B W, 0x00 C,    \ MOV     EBX , 0 [EBP]
 0x4D8B W, 0x04 C,    \ MOV     ECX , 4 [EBP]
 0x558B W, 0x08 C,    \ MOV     EDX , 8 [EBP]
 0x6D8D W, C,         \ LEA     EBP , n [EBP]
 0x5D89 W, 0x00 C,    \ MOV     0 [EBP] , EBX
 0x4D89 W, 0x04 C,    \ MOV     4 [EBP] , ECX
 0x5589 W, 0x08 C,    \ MOV     8 [EBP] , EDX
; 
I: n&  0x4623 W, C, ; 
I: n^  0x4633 W, C, ; 
I: n|  0x460B W, C, ; 
I: n+  0x4603 W, C, ; 
I: n-  0x462B W, C, ; 
I: n=  0x4633 W, C, 
      0xE883 W, 1 C, 
      0xC01B W, 
; 
I: n#  0x4633 W, C, 
      0xD8F7 W, 
      0xC01B W, ;
I: n>  0x463B W, C,
      0x9D0F W, 0xC0 C,
      0xE083 W, 1 C,
      0x48   C,
      0x6D8D W, 4 C,
; 
I: n<  0x463B W,      C,
      0x9E0F W, 0xC0 C,
      0xE083 W, 1 C,
      0x48   C,
      0x6D8D W, 4 C,
;
I: n*  0x6EF7 W, C,
      0x6D8D W, 4 C,
;
I: n/  0xC88B W,
      0x463B W, C,
      0x99   C,
      0xF9F7 W,
      0x6D8D W, 4 C,
;
I: n%  0xC88B W,
      0x463B W, C,
      0x99   C,
      0xF9F7 W,
      0x6D8D W, 4 C,
      0xC28B W,
;
I: nM  0x463B W, C,
      0xE37C W,     
      0x6D8D W, 4 C,
;
I: nm  0x463B W, C,
      0xC77F W,
      0x6D8D W, 4 C,
;

\ стековые манипуляторы, расширенные операторами (для быстрого прототипирования и отладки программных модулей)

: SPDROP ( p*n n --)  P+A DROP ;  \ убрать со стека n байтов
: SPMOVE ( p*n addr n --) $ 4 B=aP D=A D+@P L1: $ -4 Da C=@B @D=C $ 4 Ba $ 4 A-# L1 J0<> 2DROP ; \ скопировать n байтов стека в память

M: aDO   OVER + SWAP ?DO ;    \ макрос ( BOUND ?DO )
M: I+  ( n -- )  R@ + RP@ ! ; \ макрос: увеличить счетчик цикла на n со стека

: odin  1 ;
: hex   16 ;
: 4cell 32 ;
: kbyte 1024 ;
: mbyte 1048576 ;

: hAlloc  RS=S ALLOCATE THROW S=RS ;
: hFree   RS=S     FREE THROW S=RS ;
: hResize RS=S   RESIZE THROW S=RS ;

I: LAMBDA{ ( -- res xt ) 0 BRANCH, >MARK HERE ;
I: }LAMBDA ( res xt -- ) RET, >R >RESOLVE1 R> LIT, ;

I: FO ` OF ` ` ;  M: EF ENDOF ;

: conv-so   ui! ai! ai i!
  2000 ALLOCATE THROW ao! 2000 uo! ao o! ao uo ERASE
  i+( i 1+ is i )  s( o C! o 1+ is o )  
  BEGIN ''' s  i C@ i+ s i+ ''' s BL s 'F' s 'O' s BL s
        BEGIN i C@ BL > IF i C@ i+ s 0 ELSE i+ BL s 'E' s 'F' s BL s 1 THEN UNTIL
  i ai - ui >
  UNTIL ao o ao -
;
: Move RS=S MOVE S=RS ;
: Search RS=S SEARCH S=RS ;
: ).(  RS=S . S=RS ;
: Type RS=S TYPE S=RS ;
: Emit RS=S EMIT S=RS ;
: Cr RS=S CR S=RS ;
: Compare RS=S COMPARE S=RS ;

: S:  : IMMEDIATE load-str conv-so DLIT, ` EVALUATE ` ; ;
S: SYM->OPERATOR 
a ABS                      ! !          0 FALSE
b C@                       _ FILL       
c Emit                     $ ?DO        
d DUP                      % MOD        
e ELSE                     & AND        
f hFree                             
g CELL       H WITHIN               
h hAlloc     G aDO         * *          
i 1+         I I           + +          
j 1+!        J J           , LITERAL    
k KEY        K EKEY        - -
l LSHIFT     L LOOP        . ).(
m MIN        M MAX         / /
n NEGATE     N +LOOP       < <
o AGAIN      O BEGIN       = =
p DS>F       P DEPTH       > >
q Compare    Q LEAVE       ? IF
r RSHIFT     R REPEAT      @ @
s Search     S SPACES      # <>        
t THEN       T Type               
u hResize    U UNTIL       ^ XOR
v EVALUATE   V Move        
w C!         W WHILE       { LAMBDA{
x DROP       X EXECUTE     | OR
y odin       Y TRUE        } }LAMBDA
z 0<>        Z 0=          ~ INVERT                                                                  
;                   
M: XTSYM  ` LAMBDA{ I 1+ C@ CASE SYM->OPERATOR ENDCASE  ` }LAMBDA 1 I+  
;

: DOR     ( d1 d2 -- d3)  D=@P $ 8 Pa $ -4 A|@P @P|D ;
: DXOR    ( d1 d2 -- d3)  D=@P $ 8 Pa $ -4 A^@P @P^D ;
: DAND    ( d1 d2 -- d3)  D=@P $ 8 Pa $ -4 A&@P @P&D ;
: DINVERT ( d1 -- d2 )    @P~ A~ ;
: DLSHIFT ( d n -- 'd ) $ 4 D=@P $ 20 C=# C-A D>> C=A @P<< $ 4 @P<< @P|D DROP ;
: DRSHIFT ( d n -- 'd ) D=@P $ 20 C=# C-A D<< C=A @P>> $ 4 @P>> $ 4 @P|D DROP ;
: D0<>    ( d -- f ) D0= INVERT ;
: 1-! ( addr --)   @A-- DROP ;
: Dodin 1. ;
: Dnull 0. ;
: n.0b ( n -- ) 2 BASE ! .0 DECIMAL ;
: n.0h ( n -- ) HEX .0 DECIMAL ;
: .BL ( n -- ) >R 0 <# #S #> R> OVER - 0 MAX DUP IF 0 DO BL EMIT LOOP ELSE DROP THEN TYPE ;
: sqrt ( n -- sqrt )  $ -4 @P=A $ -4 0=@P 0SQRT $ -4 @P=0- $ -4 A=@P ;

\ символы с префиксом " 
S: SYM->DOPERATOR 
a DABS       Z D0=         ! 2!         0 Dnull
b W@                       & DAND        
d 2DUP                     + D+          
g 4cell                    , 2LITERAL    
l DLSHIFT                  - D-         
n DNEGATE                  . D.         
r DRSHIFT                  < D<         
w W!                       = D=         
x 2DROP                    > D>         
y Dodin                    @ 2@         
z D0<>                     ^ DXOR
                           | DOR
                           ~ DINVERT
;
S: SaveOperator 
0 o0x0  1 o1x1  2 o2x2  3 o3x3  4 o4x4 
;
S: OptOp?
^ TRUE  & TRUE  | TRUE  
+ TRUE  - TRUE  * TRUE  / TRUE  % TRUE  
= TRUE  # TRUE  > TRUE  < TRUE 
M TRUE  m TRUE
;
S: OptOperator 
^ n^  & n&  | n| 
+ n+  - n-  * n*  / n/  % n% 
= n=  # n#  > n>  < n< 
M nM  m nm
; 
: ODI 1 ; : SHE 6  ; : ODIN 11 ; 
: DVA 2 ; : SEM 7  ; : DVEN 12 ; 
: TRI 3 ; : VOS 8  ; : TRIN 13 ; 
: CHE 4 ; : DEV 9  ; : CHET 14 ; 
: PAJ 5 ; : DES 10 ; : PAJT 15 ; 


S: numbers
1 ODI   2 DVA   3 TRI   4 CHE   5 PAJ 
6 SHE   7 SEM   8 VOS   9 DEV   A DES
B ODIN  C DVEN  D TRIN  E CHET  F PAJT  
;
: CinStr { s a u  -- tf }
  0 a u + a DO I C@ s = IF DROP TRUE LEAVE THEN LOOP ;

USER-VALUE XNST 0 TO XNST
: NOTFOUND { a u  }
  d?( '1' ':' WITHIN )            h?( 'A' 'G' WITHIN )
  PDS( d? IF '0' ELSE '7' THEN - )    offs( 1 - -4 * )
  p?( C@ DUP d? >R h? R> OR )    sm( C@ DUP PDS offs )
  
  pds0[ I    C@ I C@    PDS ]
  pds1[ I 1+ C@ I 1+ C@ PDS ]
  pds2[ I 2+ C@ I 2+ C@ PDS ]
  s0?[ I    C@ = ]
  s1?[ I 1+ C@ = ]
  s2?[ I 2+ C@ = ]
\                                                       ,,  ,   ,,,   ,, ,       ,, ,, ,, ,,
\                                                        .  .     .    . .   ..   .  .  .
\ \ \ \                                                 p[  pp  p:p !p:p po1 po2 "o `p 'o ]p
\                                                       ==                       == == == ==
  a  C@ '/' = u 1 > AND 0= IF a u NOTFOUND EXIT THEN
  a u + a 1+
  ?DO  I p? I 1+ C@ '[' = AND 
     IF   pds0` TO XNST XNST 2- 4 * sset 1 I+
     ELSE '`' I C@ = I 1+ p? AND  
          IF I 1+ C@ CASE numbers ENDCASE 1 I+
          ELSE '"' I C@ = 
               IF I 1+ C@ CASE  SYM->DOPERATOR ENDCASE 1 I+
               ELSE ']' I C@ = I 1+ p? AND
                    IF XNST 4 * I 1+ C@
                       CASE SaveOperator ENDCASE 0 TO XNST 1 I+ 
                    ELSE I p? I 1+ p? 0= AND
                         IF   I 1+ C@  S" +-*/%=><#mM^|&"  CinStr
                              IF pds0` offs I 1+ C@
                                 CASE OptOperator ENDCASE 1 I+
                              
                              ELSE pds0` DUP  DUP offs N> XNST > IF TO XNST ELSE DROP THEN
                                 
                                    
                                 
                              THEN                         
                         ELSE \ I p? 

                         THEN
                    THEN
               THEN
          THEN
     THEN
   LOOP
;






